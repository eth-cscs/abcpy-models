import warnings

import numpy as np
from abcpy.continuousmodels import ProbabilisticModel, Continuous, InputConnector, Uniform
from statsmodels.tsa.arima_process import arma_generate_sample


class ARMAmodel(ProbabilisticModel, Continuous):

    def __init__(self, parameters, num_AR_params=2, num_MA_params=2, size=100, name='ARMA model'):
        """size is the length of the timeseries to be generated by the model.
        The AR parameters always need to be passed before the MA parameters."""

        if not isinstance(parameters, list):
            raise TypeError('Input of ARMAmodel model is of type list')

        self.size = size
        self.num_AR_params = num_AR_params
        self.num_MA_params = num_MA_params
        self.total_num_params = num_AR_params + num_MA_params

        self._check_num_parameters(parameters)

        input_connector = InputConnector.from_list(parameters)
        super(ARMAmodel, self).__init__(input_connector, name)

    def _check_input(self, input_values):
        # Check whether input has correct type or format
        if len(input_values) != self.total_num_params:
            return False
        return True

    def _check_num_parameters(self, input_values):
        # Check whether input has correct type or format
        if len(input_values) != self.total_num_params:
            raise RuntimeError(
                'Input list must be of length {}, containing {} AR parameters and {} MA parameters'.format(
                    self.total_num_params, self.num_AR_params, self.num_MA_params))
        return True

    def _check_output(self, values):
        # f not isinstance(values[0], np.ndarray):
        #   raise ValueError('Output of the normal distribution is always a number.')
        return True

    def get_output_dimension(self):
        return self.size

    def get_number_parameters(self):
        return self.total_num_params

    def forward_simulate(self, input_values, k, rng=np.random.RandomState()):

        self._check_num_parameters(input_values)

        results = []
        arparams = np.array(input_values[0:self.num_AR_params])
        maparams = np.array(input_values[self.num_AR_params:self.num_AR_params + self.num_MA_params])
        ar = np.r_[1, -arparams.squeeze()]  # add zero-lag and negate
        ma = np.r_[1, maparams.squeeze()]  # add zero-lag

        for i in range(k):
            # use the random number generators provided as a way to draw the random gaussians. This is for
            # reproducibility. It does not work for statsmodels after 0.9.0
            results.append(arma_generate_sample(ar, ma, self.size, distrvs=rng.randn))

            if np.any(np.isinf(results[-1])):
                warnings.warn("Infinity in forward ARMA model", RuntimeWarning)
            if np.any(np.isnan(results[-1])):
                warnings.warn("nan in forward ARMA model", RuntimeWarning)

        return results


class MA2Reparametrized(ARMAmodel):

    def __init__(self, parameters, size=100, name='MA2Reparametrized'):
        """size is the length of the timeseries to be generated by the model. Parameter inputs to this model are
        R1 and R2 variables, from which theta1, theta2 are obtained.

        We in fact consider triangular region as specified in Marin et al (2012); we sample from it using the trick
        in https://math.stackexchange.com/questions/18686/uniform-random-point-in-triangle (implemented in
        self._transform_R_to_theta). With R1 and R2 uniform in [0,1], you obtain theta1, theta2 uniform on the correct
        triangular region.
        """

        self.size = size

        ARMAmodel.__init__(self, parameters, num_AR_params=0, num_MA_params=2, size=size, name=name)

    def forward_simulate(self, input_values, num_forward_simulations, rng=np.random.RandomState()):
        R1 = input_values[0]
        R2 = input_values[1]

        theta1, theta2 = self._transform_R_to_theta(R1, R2)

        return ARMAmodel.forward_simulate(self, [theta1, theta2], k=num_forward_simulations, rng=rng)

    def _check_input(self, input_values):
        """Check whether theta1 and theta2 from the transformation satisfy the inequalities:"""

        # first check number of parameters:
        if not ARMAmodel._check_input(self, input_values):
            return False

        # then check inequalities:
        R1 = input_values[0]
        R2 = input_values[1]

        theta1, theta2 = self._transform_R_to_theta(R1, R2)
        if not (-1 < theta2 < 1 and theta1 + theta2 > -1 or theta1 - theta2 < 1):
            return False

        return True

    @staticmethod
    def _transform_R_to_theta(R1, R2):
        R1_sqrt = R1 ** 0.5
        theta1 = ((4 - 2 * R2) * R1_sqrt - 2)
        theta2 = (1 - 2 * R2 * R1_sqrt)
        return theta1, theta2


def instantiate_MA2_with_uniform_triangular_region(size=100, **kwargs):
    R1 = Uniform([[0], [1]], name='R1')
    R2 = Uniform([[0], [1]], name='R2')

    model = MA2Reparametrized([R1, R2], size=size, **kwargs)

    return model
