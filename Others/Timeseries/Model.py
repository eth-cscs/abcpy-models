import warnings

import numpy as np
from abcpy.continuousmodels import ProbabilisticModel, Continuous, InputConnector
from statsmodels.tsa.arima_process import arma_generate_sample


class ARMAmodel(ProbabilisticModel, Continuous):

    def __init__(self, parameters, num_AR_params=2, num_MA_params=2, size=100, name='ARMA model'):
        """size is the length of the timeseries to be generated by the model.
        The AR parameters always need to be passed before the MA parameters."""

        if not isinstance(parameters, list):
            raise TypeError('Input of ARMAmodel model is of type list')

        self.size = size
        self.num_AR_params = num_AR_params
        self.num_MA_params = num_MA_params
        self.total_num_params = num_AR_params + num_MA_params

        self._check_input(parameters)

        input_connector = InputConnector.from_list(parameters)
        super().__init__(input_connector, name)

    def _check_input(self, input_values):
        # Check whether input has correct type or format
        if len(input_values) != self.total_num_params:
            raise RuntimeError(
                'Input list must be of length {}, containing {} AR parameters and {} MA parameters'.format(
                    self.total_num_params, self.num_AR_params, self.num_MA_params))

        # Check whether input is from correct domain

        return True

    def _check_output(self, values):
        # f not isinstance(values[0], np.ndarray):
        #   raise ValueError('Output of the normal distribution is always a number.')
        return True

    def get_output_dimension(self):
        return self.size

    def get_number_parameters(self):
        return self.total_num_params

    def forward_simulate(self, input_values, k, rng=np.random.RandomState()):

        self._check_input(input_values)

        results = []
        arparams = np.array(input_values[0:self.num_AR_params])
        maparams = np.array(input_values[self.num_AR_params:self.num_AR_params + self.num_MA_params])
        ar = np.r_[1, -arparams]  # add zero-lag and negate
        ma = np.r_[1, maparams]  # add zero-lag

        for i in range(k):
            # use the random number generators provided as a way to draw the random gaussians. This is for
            # reproducibility. It does not work for statsmodels after 0.9.0
            results.append(arma_generate_sample(ar, ma, self.size, distrvs=rng.randn))

            if np.any(np.isinf(results[-1])):
                warnings.warn("Infinity in forward ARMA model", RuntimeWarning)
            if np.any(np.isnan(results[-1])):
                warnings.warn("nan in forward ARMA model", RuntimeWarning)

        return results
